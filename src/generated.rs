// Generated by Molecule 0.4.1

use molecule :: prelude :: * ;
use super :: super :: c :: blockchain :: * ;
# [ derive ( Clone ) ] pub struct CampaignArgs ( molecule :: bytes :: Bytes ) ; impl :: std :: fmt :: Debug for CampaignArgs { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { use molecule :: faster_hex :: hex_string ; write ! ( f , "{}(0x{})" , Self :: NAME , hex_string ( self . as_slice ( ) ) . unwrap ( ) ) } } impl :: std :: fmt :: Display for CampaignArgs { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "id" , self . id ( ) ) ? ; write ! ( f , ", {}: {}" , "period" , self . period ( ) ) ? ; write ! ( f , ", {}: {}" , "deposit" , self . deposit ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl :: std :: default :: Default for CampaignArgs { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 68 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 52 , 0 , 0 , 0 , 60 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; CampaignArgs :: new_unchecked ( v . into ( ) ) } } impl CampaignArgs { pub const FIELD_COUNT : usize = 3 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn field_offsets ( & self ) -> & [ [ u8 ; 4 ] ] { molecule :: unpack_number_vec ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn id ( & self ) -> OutPoint { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 0 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; OutPoint :: new_unchecked ( self . 0 . slice ( start , end ) ) } pub fn period ( & self ) -> Uint64 { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; Uint64 :: new_unchecked ( self . 0 . slice ( start , end ) ) } pub fn deposit ( & self ) -> Uint64 { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & offsets [ 3 ] [ .. ] ) as usize ; Uint64 :: new_unchecked ( self . 0 . slice ( start , end ) ) } else { Uint64 :: new_unchecked ( self . 0 . slice_from ( start ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> CampaignArgsReader < 'r > { CampaignArgsReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for CampaignArgs { type Builder = CampaignArgsBuilder ; const NAME : & 'static str = "CampaignArgs" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { CampaignArgs ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { CampaignArgsReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { CampaignArgsReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: std :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . id ( self . id ( ) ) . period ( self . period ( ) ) . deposit ( self . deposit ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct CampaignArgsReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: std :: fmt :: Debug for CampaignArgsReader < 'r > { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { use molecule :: faster_hex :: hex_string ; write ! ( f , "{}(0x{})" , Self :: NAME , hex_string ( self . as_slice ( ) ) . unwrap ( ) ) } } impl < 'r > :: std :: fmt :: Display for CampaignArgsReader < 'r > { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "id" , self . id ( ) ) ? ; write ! ( f , ", {}: {}" , "period" , self . period ( ) ) ? ; write ! ( f , ", {}: {}" , "deposit" , self . deposit ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl < 'r > CampaignArgsReader < 'r > { pub const FIELD_COUNT : usize = 3 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn field_offsets ( & self ) -> & [ [ u8 ; 4 ] ] { molecule :: unpack_number_vec ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn id ( & self ) -> OutPointReader < 'r > { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 0 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; OutPointReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn period ( & self ) -> Uint64Reader < 'r > { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; Uint64Reader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn deposit ( & self ) -> Uint64Reader < 'r > { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & offsets [ 3 ] [ .. ] ) as usize ; Uint64Reader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } else { Uint64Reader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CampaignArgsReader < 'r > { type Entity = CampaignArgs ; const NAME : & 'static str = "CampaignArgsReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { CampaignArgsReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ? ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ? ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len ) ? ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { ve ! ( Self , OffsetsNotMatch ) ? ; } let field_count = offset_first / 4 - 1 ; if field_count < Self :: FIELD_COUNT { ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ? ; } else if ! compatible && field_count > Self :: FIELD_COUNT { ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ? ; } ; let header_size = molecule :: NUMBER_SIZE * ( field_count + 1 ) ; if slice_len < header_size { ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ? ; } let ptr = molecule :: unpack_number_vec ( & slice [ molecule :: NUMBER_SIZE .. ] ) ; let mut offsets : Vec < usize > = ptr [ .. field_count ] . iter ( ) . map ( | x | molecule :: unpack_number ( & x [ .. ] ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { ve ! ( Self , OffsetsNotMatch ) ? ; } OutPointReader :: verify ( & slice [ offsets [ 0 ] .. offsets [ 1 ] ] , compatible ) ? ; Uint64Reader :: verify ( & slice [ offsets [ 1 ] .. offsets [ 2 ] ] , compatible ) ? ; Uint64Reader :: verify ( & slice [ offsets [ 2 ] .. offsets [ 3 ] ] , compatible ) ? ; Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct CampaignArgsBuilder { pub ( crate ) id : OutPoint , pub ( crate ) period : Uint64 , pub ( crate ) deposit : Uint64 , } impl CampaignArgsBuilder { pub const FIELD_COUNT : usize = 3 ; pub fn id ( mut self , v : OutPoint ) -> Self { self . id = v ; self } pub fn period ( mut self , v : Uint64 ) -> Self { self . period = v ; self } pub fn deposit ( mut self , v : Uint64 ) -> Self { self . deposit = v ; self } } impl molecule :: prelude :: Builder for CampaignArgsBuilder { type Entity = CampaignArgs ; const NAME : & 'static str = "CampaignArgsBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) + self . id . as_slice ( ) . len ( ) + self . period . as_slice ( ) . len ( ) + self . deposit . as_slice ( ) . len ( ) } fn write < W : :: std :: io :: Write > ( & self , writer : & mut W ) -> :: std :: io :: Result < ( ) > { let mut total_size = molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) ; let mut offsets = Vec :: with_capacity ( Self :: FIELD_COUNT ) ; offsets . push ( total_size ) ; total_size += self . id . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . period . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . deposit . as_slice ( ) . len ( ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } writer . write_all ( self . id . as_slice ( ) ) ? ; writer . write_all ( self . period . as_slice ( ) ) ? ; writer . write_all ( self . deposit . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; CampaignArgs :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct IndexVec ( molecule :: bytes :: Bytes ) ; impl :: std :: fmt :: Debug for IndexVec { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { use molecule :: faster_hex :: hex_string ; write ! ( f , "{}(0x{})" , Self :: NAME , hex_string ( self . as_slice ( ) ) . unwrap ( ) ) } } impl :: std :: fmt :: Display for IndexVec { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl :: std :: default :: Default for IndexVec { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , ] ; IndexVec :: new_unchecked ( v . into ( ) ) } } impl IndexVec { pub const ITEM_SIZE : usize = 4 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < Uint32 > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> Uint32 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint32 :: new_unchecked ( self . 0 . slice ( start , end ) ) } pub fn as_reader < 'r > ( & 'r self ) -> IndexVecReader < 'r > { IndexVecReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for IndexVec { type Builder = IndexVecBuilder ; const NAME : & 'static str = "IndexVec" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { IndexVec ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { IndexVecReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { IndexVecReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: std :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . extend ( self . into_iter ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct IndexVecReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: std :: fmt :: Debug for IndexVecReader < 'r > { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { use molecule :: faster_hex :: hex_string ; write ! ( f , "{}(0x{})" , Self :: NAME , hex_string ( self . as_slice ( ) ) . unwrap ( ) ) } } impl < 'r > :: std :: fmt :: Display for IndexVecReader < 'r > { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl < 'r > IndexVecReader < 'r > { pub const ITEM_SIZE : usize = 4 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < Uint32Reader < 'r > > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> Uint32Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint32Reader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for IndexVecReader < 'r > { type Entity = IndexVec ; const NAME : & 'static str = "IndexVecReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { IndexVecReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ? ; } let item_count = molecule :: unpack_number ( slice ) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { ve ! ( Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len ) ? ; } return Ok ( ( ) ) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ? ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct IndexVecBuilder ( pub ( crate ) Vec < Uint32 > ) ; impl IndexVecBuilder { pub const ITEM_SIZE : usize = 4 ; pub fn set ( mut self , v : Vec < Uint32 > ) -> Self { self . 0 = v ; self } pub fn push ( mut self , v : Uint32 ) -> Self { self . 0 . push ( v ) ; self } pub fn extend < T : :: std :: iter :: IntoIterator < Item = Uint32 >> ( mut self , iter : T ) -> Self { for elem in iter { self . 0 . push ( elem ) ; } self } } impl molecule :: prelude :: Builder for IndexVecBuilder { type Entity = IndexVec ; const NAME : & 'static str = "IndexVecBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len ( ) } fn write < W : :: std :: io :: Write > ( & self , writer : & mut W ) -> :: std :: io :: Result < ( ) > { writer . write_all ( & molecule :: pack_number ( self . 0 . len ( ) as molecule :: Number ) ) ? ; for inner in & self . 0 [ .. ] { writer . write_all ( inner . as_slice ( ) ) ? ; } Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; IndexVec :: new_unchecked ( inner . into ( ) ) } }
pub struct IndexVecIterator ( IndexVec , usize , usize ) ; impl :: std :: iter :: Iterator for IndexVecIterator { type Item = Uint32 ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl :: std :: iter :: ExactSizeIterator for IndexVecIterator { fn len ( & self ) -> usize { self . 2 - self . 1 } } impl :: std :: iter :: IntoIterator for IndexVec { type Item = Uint32 ; type IntoIter = IndexVecIterator ; fn into_iter ( self ) -> Self :: IntoIter { let len = self . len ( ) ; IndexVecIterator ( self , 0 , len ) } } impl < 'r > IndexVecReader < 'r > { pub fn iter < 't > ( & 't self ) -> IndexVecReaderIterator < 't , 'r > { IndexVecReaderIterator ( & self , 0 , self . len ( ) ) } } pub struct IndexVecReaderIterator < 't , 'r > ( & 't IndexVecReader < 'r > , usize , usize ) ; impl < 't : 'r , 'r > :: std :: iter :: Iterator for IndexVecReaderIterator < 't , 'r > { type Item = Uint32Reader < 't > ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl < 't : 'r , 'r > :: std :: iter :: ExactSizeIterator for IndexVecReaderIterator < 't , 'r > { fn len ( & self ) -> usize { self . 2 - self . 1 } }
# [ derive ( Clone ) ] pub struct Summary ( molecule :: bytes :: Bytes ) ; impl :: std :: fmt :: Debug for Summary { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { use molecule :: faster_hex :: hex_string ; write ! ( f , "{}(0x{})" , Self :: NAME , hex_string ( self . as_slice ( ) ) . unwrap ( ) ) } } impl :: std :: fmt :: Display for Summary { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "reveals" , self . reveals ( ) ) ? ; write ! ( f , ", {}: {}" , "unreveals" , self . unreveals ( ) ) ? ; write ! ( f , ", {}: {}" , "reveals_hash" , self . reveals_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "lock" , self . lock ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl :: std :: default :: Default for Summary { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 113 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 60 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 53 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 49 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; Summary :: new_unchecked ( v . into ( ) ) } } impl Summary { pub const FIELD_COUNT : usize = 4 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn field_offsets ( & self ) -> & [ [ u8 ; 4 ] ] { molecule :: unpack_number_vec ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn reveals ( & self ) -> IndexVec { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 0 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; IndexVec :: new_unchecked ( self . 0 . slice ( start , end ) ) } pub fn unreveals ( & self ) -> IndexVec { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; IndexVec :: new_unchecked ( self . 0 . slice ( start , end ) ) } pub fn reveals_hash ( & self ) -> Byte32 { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 3 ] [ .. ] ) as usize ; Byte32 :: new_unchecked ( self . 0 . slice ( start , end ) ) } pub fn lock ( & self ) -> Script { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 3 ] [ .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & offsets [ 4 ] [ .. ] ) as usize ; Script :: new_unchecked ( self . 0 . slice ( start , end ) ) } else { Script :: new_unchecked ( self . 0 . slice_from ( start ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> SummaryReader < 'r > { SummaryReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for Summary { type Builder = SummaryBuilder ; const NAME : & 'static str = "Summary" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { Summary ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SummaryReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SummaryReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: std :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . reveals ( self . reveals ( ) ) . unreveals ( self . unreveals ( ) ) . reveals_hash ( self . reveals_hash ( ) ) . lock ( self . lock ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct SummaryReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: std :: fmt :: Debug for SummaryReader < 'r > { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { use molecule :: faster_hex :: hex_string ; write ! ( f , "{}(0x{})" , Self :: NAME , hex_string ( self . as_slice ( ) ) . unwrap ( ) ) } } impl < 'r > :: std :: fmt :: Display for SummaryReader < 'r > { fn fmt ( & self , f : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "reveals" , self . reveals ( ) ) ? ; write ! ( f , ", {}: {}" , "unreveals" , self . unreveals ( ) ) ? ; write ! ( f , ", {}: {}" , "reveals_hash" , self . reveals_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "lock" , self . lock ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl < 'r > SummaryReader < 'r > { pub const FIELD_COUNT : usize = 4 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn field_offsets ( & self ) -> & [ [ u8 ; 4 ] ] { molecule :: unpack_number_vec ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn reveals ( & self ) -> IndexVecReader < 'r > { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 0 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; IndexVecReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn unreveals ( & self ) -> IndexVecReader < 'r > { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 1 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; IndexVecReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn reveals_hash ( & self ) -> Byte32Reader < 'r > { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 2 ] [ .. ] ) as usize ; let end = molecule :: unpack_number ( & offsets [ 3 ] [ .. ] ) as usize ; Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn lock ( & self ) -> ScriptReader < 'r > { let offsets = self . field_offsets ( ) ; let start = molecule :: unpack_number ( & offsets [ 3 ] [ .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & offsets [ 4 ] [ .. ] ) as usize ; ScriptReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } else { ScriptReader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for SummaryReader < 'r > { type Entity = Summary ; const NAME : & 'static str = "SummaryReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { SummaryReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ? ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ? ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len ) ? ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { ve ! ( Self , OffsetsNotMatch ) ? ; } let field_count = offset_first / 4 - 1 ; if field_count < Self :: FIELD_COUNT { ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ? ; } else if ! compatible && field_count > Self :: FIELD_COUNT { ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ? ; } ; let header_size = molecule :: NUMBER_SIZE * ( field_count + 1 ) ; if slice_len < header_size { ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ? ; } let ptr = molecule :: unpack_number_vec ( & slice [ molecule :: NUMBER_SIZE .. ] ) ; let mut offsets : Vec < usize > = ptr [ .. field_count ] . iter ( ) . map ( | x | molecule :: unpack_number ( & x [ .. ] ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { ve ! ( Self , OffsetsNotMatch ) ? ; } IndexVecReader :: verify ( & slice [ offsets [ 0 ] .. offsets [ 1 ] ] , compatible ) ? ; IndexVecReader :: verify ( & slice [ offsets [ 1 ] .. offsets [ 2 ] ] , compatible ) ? ; Byte32Reader :: verify ( & slice [ offsets [ 2 ] .. offsets [ 3 ] ] , compatible ) ? ; ScriptReader :: verify ( & slice [ offsets [ 3 ] .. offsets [ 4 ] ] , compatible ) ? ; Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct SummaryBuilder { pub ( crate ) reveals : IndexVec , pub ( crate ) unreveals : IndexVec , pub ( crate ) reveals_hash : Byte32 , pub ( crate ) lock : Script , } impl SummaryBuilder { pub const FIELD_COUNT : usize = 4 ; pub fn reveals ( mut self , v : IndexVec ) -> Self { self . reveals = v ; self } pub fn unreveals ( mut self , v : IndexVec ) -> Self { self . unreveals = v ; self } pub fn reveals_hash ( mut self , v : Byte32 ) -> Self { self . reveals_hash = v ; self } pub fn lock ( mut self , v : Script ) -> Self { self . lock = v ; self } } impl molecule :: prelude :: Builder for SummaryBuilder { type Entity = Summary ; const NAME : & 'static str = "SummaryBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) + self . reveals . as_slice ( ) . len ( ) + self . unreveals . as_slice ( ) . len ( ) + self . reveals_hash . as_slice ( ) . len ( ) + self . lock . as_slice ( ) . len ( ) } fn write < W : :: std :: io :: Write > ( & self , writer : & mut W ) -> :: std :: io :: Result < ( ) > { let mut total_size = molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) ; let mut offsets = Vec :: with_capacity ( Self :: FIELD_COUNT ) ; offsets . push ( total_size ) ; total_size += self . reveals . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . unreveals . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . reveals_hash . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . lock . as_slice ( ) . len ( ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } writer . write_all ( self . reveals . as_slice ( ) ) ? ; writer . write_all ( self . unreveals . as_slice ( ) ) ? ; writer . write_all ( self . reveals_hash . as_slice ( ) ) ? ; writer . write_all ( self . lock . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; Summary :: new_unchecked ( inner . into ( ) ) } }
